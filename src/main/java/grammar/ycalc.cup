import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/** Terminals */

terminal           AND, OR, NOT, TRUE, FALSE; // boolean

// flow
terminal           BEGIN, END, EXIT;
terminal           IF, THEN, ELSE;

terminal           PRINT, READ;
terminal           ASSIGN;
terminal   	       EQ, LT, LE, GT, GE, NE; // int_rel

terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, MODE, LPAREN, RPAREN;
terminal Integer   INT;
terminal Double    DOUBLE;
terminal String    IDENT;
terminal String    STRING;


/** Non-terminals **/
non terminal Expression expr;
non terminal Expression int_expr;
non terminal Expression double_expr;
non terminal Expression str_expr;
non terminal Expression bool_expr;

non terminal Operator int_op;
non terminal Condition int_rel;

non terminal Operator double_op;
non terminal Condition double_rel;

non terminal Instruction instruction;
non terminal InstructionList instr;

non terminal Instruction assign_stat;
non terminal Instruction if_stat;
//non terminal Instruction while_stat;
non terminal Instruction output_stat;
non terminal Main program;

/** Precedence */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODE;

precedence left OR, AND;
precedence left NOT;

precedence left ELSE;

start with program;

/** ============= GRAMMAR ============= */

/** done */
int_op ::= PLUS             {: RESULT = new PlusIntOperator(); :}
         | MINUS            {: RESULT = new MinusIntOperator(); :}
         | TIMES            {: RESULT = new TimesIntOperator(); :}
         | DIVIDE           {: RESULT = new DivideIntOperator(); :}
         | MODE             {: RESULT = new ModeIntOperator(); :}
         ;

double_op ::= PLUS          {: RESULT = new PlusDoubleOperator(); :}
         | MINUS            {: RESULT = new MinusDoubleOperator(); :}
         | TIMES            {: RESULT = new TimesDoubleOperator(); :}
         | DIVIDE           {: RESULT = new DivideDoubleOperator(); :}
         ;

expr ::= IDENT:i            {: RESULT = new ID(i); :}
            |int_expr:e     {: RESULT = e; :}
            |double_expr:e  {: RESULT = e; :}
            |str_expr:e     {: RESULT = e; :}
            ;

int_expr ::=  INT:e
                {:
                    RESULT = new IntExpression(e.intValue());
                :}
            | MINUS expr:e
                {:
                    RESULT = new UMinusIntExpression(e);
                :}
            | expr:e int_op:o expr:e2
                {:
                    RESULT = new OperatorExpression(e, o, e2);
                :}
            ;

double_expr ::=  DOUBLE:e
                {:
                    RESULT = new DoubleExpression(e.doubleValue());
                :}
            | MINUS expr:e
                {:
                    RESULT = new UMinusDoubleExpression(e);
                :}
            | expr:e double_op:o expr:e2
                {:
                    RESULT = new OperatorExpression(e, o, e2);
                :}
            ;

str_expr ::=  STRING:s
                {:
                    RESULT = new StringExpression(s.substring(1, s.length()-1));
                :}
             ;

int_rel ::=   EQ         {: RESULT = new EqualsCondition(); :}
            | LT         {: RESULT = new LessThanCondition(); :}
            | LE         {: RESULT = new LessOrEqualsCondition(); :}
            | GT         {: RESULT = new GreaterThanCondition(); :}
            | GE         {: RESULT = new GreaterOrEqualsCondition(); :}
            | NE         {: RESULT = new NotEqualsCondition(); :}
            ;

double_rel ::=   EQ         {: RESULT = new EqualsCondition(); :}
            | LT            {: RESULT = new LessThanCondition(); :}
            | LE            {: RESULT = new LessOrEqualsCondition(); :}
            | GT            {: RESULT = new GreaterThanCondition(); :}
            | GE            {: RESULT = new GreaterOrEqualsCondition(); :}
            | NE            {: RESULT = new NotEqualsCondition(); :}
            ;

bool_expr ::= TRUE                               {: RESULT = new BooleanExpression(true); :}
            | FALSE                              {: RESULT = new BooleanExpression(false); :}
            | NOT bool_expr:e                    {: RESULT = new NegationBooleanExpression(e); :}
            | bool_expr:e AND bool_expr:e2       {: RESULT = new AndBooleanExpression(e, e2); :}
            | bool_expr:e OR bool_expr:e2        {: RESULT = new OrBooleanExpression(e, e2); :}
            | expr: e int_rel:o expr:e2          {: RESULT = new ConditionBooleanExpression(e, o, e2); :}
            ;

instruction ::= assign_stat:si                   {: RESULT = si; :}
              | if_stat:si                       {: RESULT = si; :}
              | BEGIN instr:si END               {: RESULT = new BeginEndInstruction(si); :}
              | output_stat:si                   {: RESULT = si; :}
              | EXIT                             {: System.exit(0); :}
              ;
// TODO: CHANGE TO \n
instr ::= instr:i SEMI instruction:si           {: i.add(si); RESULT = i; :}
        | instruction:si                        {: RESULT = new InstructionList(si); :}
        ;

assign_stat ::= IDENT:i ASSIGN expr:e          {: RESULT = new AssignInstruction(i,e); :}
                ;

if_stat ::= IF bool_expr:c THEN instruction:s                          {: RESULT = new IfInstruction(c, s); :}
            | IF bool_expr:c THEN instruction:s ELSE instruction:s2   {:  RESULT = new IfElseInstruction(c, s, s2); :}
            ;

output_stat ::= PRINT LPAREN expr:e  RPAREN             {: RESULT = new OutputInstruction(e); :}
            ;

input_stat ::= READ LPAREN expr:e RPAREN                {: RESULT = new ReadExpression(); :}
            ;

program ::= instr:i
          {:
            Main program = new Main(i);
            program.exec();
          :}
          ;